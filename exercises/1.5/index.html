<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Exercise 1.5 | Adventures in SICP with AI</title>
<meta name="keywords" content="sicp, scheme">
<meta name="description" content="The Exercise
Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation or normal-order evaluation. He defines the following two procedures:



    
        

1
2
3
4
5
6


(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))


    

Then he evaluates the expression


1


(test 0 (p))


What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation rule for the special form if is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)">
<meta name="author" content="">
<link rel="canonical" href="https://myleshenderson.github.io/exercises/1.5/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.87f24592957150a8347ef62b9868daf26d6e7cd2f518c5161fa75ca073e894b2.css" integrity="sha256-h/JFkpVxUKg0fvYrmGja8m1ufNL1GMUWH6dcoHPolLI=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://myleshenderson.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://myleshenderson.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://myleshenderson.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://myleshenderson.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://myleshenderson.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://myleshenderson.github.io/exercises/1.5/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
<meta property="og:title" content="Exercise 1.5">
<meta property="og:description" content="The Exercise
Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation or normal-order evaluation. He defines the following two procedures:



    
        

1
2
3
4
5
6


(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))


    

Then he evaluates the expression


1


(test 0 (p))


What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation rule for the special form if is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)">
<meta property="og:type" content="article">
<meta property="og:url" content="https://myleshenderson.github.io/exercises/1.5/"><meta property="article:section" content="exercises">


<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Exercise 1.5">
<meta name="twitter:description" content="The Exercise
Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation or normal-order evaluation. He defines the following two procedures:



    
        

1
2
3
4
5
6


(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))


    

Then he evaluates the expression


1


(test 0 (p))


What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation rule for the special form if is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Exercises",
      "item": "https://myleshenderson.github.io/exercises/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Exercise 1.5",
      "item": "https://myleshenderson.github.io/exercises/1.5/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Exercise 1.5",
  "name": "Exercise 1.5",
  "description": "The Exercise Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation or normal-order evaluation. He defines the following two procedures:\n1 2 3 4 5 6 (define (p) (p)) (define (test x y) (if (= x 0) 0 y)) Then he evaluates the expression\n1 (test 0 (p)) What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation rule for the special form if is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)\n",
  "keywords": [
    "sicp", "scheme"
  ],
  "articleBody": "The Exercise Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation or normal-order evaluation. He defines the following two procedures:\n1 2 3 4 5 6 (define (p) (p)) (define (test x y) (if (= x 0) 0 y)) Then he evaluates the expression\n1 (test 0 (p)) What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation rule for the special form if is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)\nResponse Applicative order evaluation is “evaluate the arguments and then apply”. So the interpreter will first evaluate (p) and then apply the result to test. Since (p) will never terminate, the interpreter will never terminate.\nNormal order evaluation is “fully expand and then reduce”. So the interpreter will first expand (test 0 (p)) to (if (= 0 0) 0 (p)) and then reduce it to 0.\nChat Transcript - Tab 1 User: Critique my description of the behavior. Provide notes on what I am overlooking. AI (claude-3.5-sonnet): Your explanation is generally correct, but I can help add some important nuance to make it more precise:\nApplicative Order (your explanation is correct)\nYou’re right that the interpreter will hang because (p) needs to be evaluated first (p) is an infinite recursion that calls itself forever This matches how most modern languages and Scheme implementations work Normal Order (needs more detail)\nYour explanation is correct but could be more detailed Here’s the step-by-step expansion: (test 0 (p)) is expanded by substituting the body of test Becomes (if (= 0 0) 0 (p)) The predicate (= 0 0) is evaluated first (as noted in the exercise’s parenthetical note) Since it’s true, the consequent 0 is returned Crucially, (p) is never evaluated because it’s in the alternative branch The key insight is that normal-order evaluation only evaluates expressions when their values are actually needed The main thing you’re not emphasizing enough is that this is actually a very clever test because it specifically takes advantage of how if works as a special form. The fact that if only evaluates the branch that’s taken is what makes this test definitively distinguish between the two evaluation orders.\nWould you like me to suggest an edit to your markdown file to incorporate these details?\nUser: No. AI (claude-3.5-sonnet): Understood! Let me know if you have any other questions. ",
  "wordCount" : "437",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://myleshenderson.github.io/exercises/1.5/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Adventures in SICP with AI",
    "logo": {
      "@type": "ImageObject",
      "url": "https://myleshenderson.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://myleshenderson.github.io/" accesskey="h" title="Adventures in SICP with AI (Alt + H)">Adventures in SICP with AI</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Exercise 1.5
    </h1>
    <div class="post-meta">3 min

</div>
  </header> 
  <div class="post-content"><h2 id="the-exercise">The Exercise<a hidden class="anchor" aria-hidden="true" href="#the-exercise">#</a></h2>
<p>Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation or normal-order evaluation. He defines the following two procedures:</p>



    
        <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scheme" data-lang="scheme"><span class="line"><span class="cl"><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">p</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="mi">0</span>
</span></span><span class="line"><span class="cl">      <span class="nv">y</span><span class="p">))</span></span></span></code></pre></td></tr></table>
</div>
</div>
    

<p>Then he evaluates the expression</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scheme" data-lang="scheme"><span class="line"><span class="cl"><span class="p">(</span><span class="nf">test</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">p</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation rule for the special form if is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)</p>
<h2 id="response">Response<a hidden class="anchor" aria-hidden="true" href="#response">#</a></h2>
<p>Applicative order evaluation is &ldquo;evaluate the arguments and then apply&rdquo;. So the interpreter will first evaluate <code>(p)</code> and then apply the result to <code>test</code>. Since <code>(p)</code> will never terminate, the interpreter will never terminate.</p>
<p>Normal order evaluation is &ldquo;fully expand and then reduce&rdquo;. So the interpreter will first expand <code>(test 0 (p))</code> to <code>(if (= 0 0) 0 (p))</code> and then reduce it to <code>0</code>.</p>




  
  
    
      
      
      
      <div class="chat-transcript">
        
          <h2 class="chat-title">Chat Transcript - Tab 1
</h2>
        
        
        <div class="chat-messages">
          
          
            
            
              <div class="chat-message user">
                <div class="message-header">User:</div>
                <div class="message-content">
                  Critique my description of the behavior. Provide notes on what I am overlooking.
                </div>
              </div>
            
          
            
            
              
              
              
              <div class="chat-message ai">
                <div class="message-header">AI (claude-3.5-sonnet):</div>
                <div class="message-content">
                  <p>Your explanation is generally correct, but I can help add some important nuance to make it more precise:</p>
<ol>
<li>
<p><strong>Applicative Order (your explanation is correct)</strong></p>
<ul>
<li>You&rsquo;re right that the interpreter will hang because <code>(p)</code> needs to be evaluated first</li>
<li><code>(p)</code> is an infinite recursion that calls itself forever</li>
<li>This matches how most modern languages and Scheme implementations work</li>
</ul>
</li>
<li>
<p><strong>Normal Order (needs more detail)</strong></p>
<ul>
<li>Your explanation is correct but could be more detailed</li>
<li>Here&rsquo;s the step-by-step expansion:
<ol>
<li><code>(test 0 (p))</code> is expanded by substituting the body of <code>test</code></li>
<li>Becomes <code>(if (= 0 0) 0 (p))</code></li>
<li>The predicate <code>(= 0 0)</code> is evaluated first (as noted in the exercise&rsquo;s parenthetical note)</li>
<li>Since it&rsquo;s true, the consequent <code>0</code> is returned</li>
<li>Crucially, <code>(p)</code> is never evaluated because it&rsquo;s in the alternative branch</li>
</ol>
</li>
<li>The key insight is that normal-order evaluation only evaluates expressions when their values are actually needed</li>
</ul>
</li>
</ol>
<p>The main thing you&rsquo;re not emphasizing enough is that this is actually a very clever test because it specifically takes advantage of how <code>if</code> works as a special form. The fact that <code>if</code> only evaluates the branch that&rsquo;s taken is what makes this test definitively distinguish between the two evaluation orders.</p>
<p>Would you like me to suggest an edit to your markdown file to incorporate these details?</p>

                </div>
              </div>
            
          
            
            
              <div class="chat-message user">
                <div class="message-header">User:</div>
                <div class="message-content">
                  No.
                </div>
              </div>
            
          
            
            
              
              
              
              <div class="chat-message ai">
                <div class="message-header">AI (claude-3.5-sonnet):</div>
                <div class="message-content">
                  Understood! Let me know if you have any other questions.
                </div>
              </div>
            
          
        </div>
      </div>
      
      <hr class="chat-separator">
    
  
 


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://myleshenderson.github.io/tags/sicp/">Sicp</a></li>
      <li><a href="https://myleshenderson.github.io/tags/scheme/">Scheme</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://myleshenderson.github.io/">Adventures in SICP with AI</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\[", right: "\\]", display: true},
                {left: "\\(", right: "\\)", display: false}
            ],
            throwOnError : false
        });
    });
</script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
